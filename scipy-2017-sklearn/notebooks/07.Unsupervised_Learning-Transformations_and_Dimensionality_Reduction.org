#+TITLE: Unsupervised Learning part 1 -- Transformation



#+BEGIN_SRC ipython :session :exports both :async t :results raw drawer
%matplotlib inline
import matplotlib.pyplot as plt
import numpy as np

#+END_SRC

#+RESULTS:
:RESULTS:
# Out[15]:
:END:

* Unsupervised Learning Part 1 -- Transformation
Many instances of unsupervised learning, such as dimensionality reduction,
manifold learning, and feature extraction, find a new representation of the
input data without any additional input. (In contrast to supervised learning,
usnupervised algorithms don't require or consider target variables like in the
previous classification and regression examples).

file:figures/unsupervised_workflow.png

A very basic example is the rescaling of our data, which is a requirement for
many machine learning algorithms as they are not scale-invariant -- rescaling
falls into the category of data pre-processing and can barely be called
learning. There exist many different rescaling technques, and in the following
example, we will take a look at a particular method that is commonly called
"standardization." Here, we will recale the data so that each feature is
centered at zero (mean = 0) with unit variance (standard deviation = 0).

For example, if we have a 1D dataset with the values [1, 2, 3, 4, 5], the standardized values are

1 -> -1.41
2 -> -0.71
3 -> 0.0
4 -> 0.71
5 -> 1.41

computed via the equation $x_{standardized} = \frac{x - \mu_x}{\sigma_x}$ ,
where μ is the sample mean, and σ the standard deviation, respectively.


#+BEGIN_SRC ipython :session :exports both :async t :results raw drawer
ary = np.array([1, 2, 3, 4, 5])
ary_standardized = (ary - ary.mean()) / ary.std()
ary_standardized

#+END_SRC

#+RESULTS:
:RESULTS:
# Out[16]:
: array([-1.41421356, -0.70710678,  0.        ,  0.70710678,  1.41421356])
:END:

Although standardization is a most basic preprocessing procedure -- as we've
seen in the code snipped above -- scikit-learn implements a StandardScaler class
for this computation. And in later sections, we will see why and when the
scikit-learn interface comes in handy over the code snippet we executed above.

Applying such a preprocessing has a very similar interface to the supervised
learning algorithms we saw so far. To get some more practice with scikit-learn's
"Transformer" interface, let's start by loading the iris dataset and rescale it:


#+BEGIN_SRC ipython :session :exports both :async t :results raw drawer
  from sklearn.datasets import load_iris
  from sklearn.model_selection import train_test_split
  ​
  iris = load_iris()
  X_train, X_test, y_train, y_test = train_test_split(iris.data, iris.target, random_state=0)
  print(X_train.shape)

#+END_SRC

#+RESULTS:
:RESULTS:
0 - ad0d09d5-893c-4640-a280-fb150af43b9a
:END:

The iris dataset is not "centered" that is it has non-zero mean and the standard
deviation is different for each component:

#+BEGIN_SRC ipython :session :exports both :async t :results raw drawer
print("mean : %s " % X_train.mean(axis=0))
print("standard deviation : %s " % X_train.std(axis=0))

#+END_SRC

#+RESULTS:
:RESULTS:
# Out[21]:
:END:

To use a preprocessing method, we first import the estimator, here
StandardScaler and instantiate it:


#+BEGIN_SRC ipython :session :exports both :async t :results raw drawer
from sklearn.preprocessing import StandardScaler
scaler = StandardScaler()

#+END_SRC

#+RESULTS:
:RESULTS:
# Out[22]:
:END:

As with the classification and regression algorithms, we call fit to learn the
model from the data. As this is an unsupervised model, we only pass X, not y.
This simply estimates mean and standard deviation.


#+BEGIN_SRC ipython :session :exports both :async t :results raw drawer
scaler.fit(X_train)
#+END_SRC

#+RESULTS:
:RESULTS:
# Out[23]:
: StandardScaler(copy=True, with_mean=True, with_std=True)
:END:

Now we can rescale our data by applying the transform (not predict) method:


#+BEGIN_SRC ipython :session :exports both :async t :results raw drawer
X_train_scaled = scaler.transform(X_train)

#+END_SRC

#+RESULTS:
:RESULTS:
# Out[24]:
:END:

X_train_scaled has the same number of samples and features, but the mean was
subtracted and all features were scaled to have unit standard deviation:


#+BEGIN_SRC ipython :session :exports both :async t :results raw drawer
print(X_train_scaled.shape)

print("mean : %s " % X_train_scaled.mean(axis=0))
print("standard deviation : %s " % X_train_scaled.std(axis=0))

#+END_SRC

#+RESULTS:
:RESULTS:
# Out[25]:
:END:

To summarize: Via the fit method, the estimator is fitted to the data we
provide. In this step, the estimator estimates the parameters from the data
(here: mean and standard deviation). Then, if we transform data, these
parameters are used to transform a dataset. (Please note that the transform
method does not update these parameters).

It's important to note that the same transformation is applied to the training
and the test set. That has the consequence that usually the mean of the test
data is not zero after scaling:


#+BEGIN_SRC ipython :session :exports both :async t :results raw drawer
X_test_scaled = scaler.transform(X_test)
print("mean test data: %s" % X_test_scaled.mean(axis=0))

#+END_SRC

#+RESULTS:
:RESULTS:
# Out[26]:
:END:

It is important for the training and test data to be transformed in exactly the
same way, for the following processing steps to make sense of the data, as is
illustrated in the figure below:


#+BEGIN_SRC ipython :session :exports both :async t :results raw drawer
from figures import plot_relative_scaling
plot_relative_scaling()

#+END_SRC

#+RESULTS:
:RESULTS:
# Out[27]:
[[file:./obipy-resources/8573eFe.png]]
:END:

There are several common ways to scale the data. The most common one is the
StandardScaler we just introduced, but rescaling the data to a fix minimum an
maximum value with MinMaxScaler (usually between 0 and 1), or using more robust
statistics like median and quantile, instead of mean and standard deviation
(with RobustScaler), are also useful.

#+BEGIN_SRC ipython :session :exports both :async t :results raw drawer
from figures import plot_scaling
plot_scaling()

#+END_SRC

#+RESULTS:
:RESULTS:
# Out[28]:
[[file:./obipy-resources/8573rPk.png]]
:END:

** Principal Component Analysis
An unsupervised transformation that is somewhat more interesting is Principal
Component Analysis (PCA). It is a technique to reduce the dimensionality of the
data, by creating a linear projection. That is, we find new features to
represent the data that are a linear combination of the old data (i.e. we rotate
it). Thus, we can think of PCA as a projection of our data onto a new feature
space.

The way PCA finds these new directions is by looking for the directions of
maximum variance. Usually only few components that explain most of the variance
in the data are kept. Here, the premise is to reduce the size (dimensionality)
of a dataset while capturing most of its information. There are many reason why
dimensionality reduction can be useful: It can reduce the computational cost
when running learning algorithms, decrease the storage space, and may help with
the so-called "curse of dimensionality," which we will discuss in greater detail
later.

To illustrate how a rotation might look like, we first show it on
two-dimensional data and keep both principal components. Here is an
illustration:


#+BEGIN_SRC ipython :session :exports both :async t :results raw drawer
from figures import plot_pca_illustration
plot_pca_illustration()

#+END_SRC

#+RESULTS:
:RESULTS:
# Out[29]:
[[file:./obipy-resources/85734Zq.png]]
:END:

Now let's go through all the steps in more detail: We create a Gaussian blob that is rotated:


#+BEGIN_SRC ipython :session :exports both :async t :results raw drawer
rnd = np.random.RandomState(5)
X_ = rnd.normal(size=(300, 2))
X_blob = np.dot(X_, rnd.normal(size=(2, 2))) + rnd.normal(size=2)
y = X_[:, 0] > 0
plt.scatter(X_blob[:, 0], X_blob[:, 1], c=y, linewidths=0, s=30)
plt.xlabel("feature 1")
plt.ylabel("feature 2");

#+END_SRC

#+RESULTS:
:RESULTS:
# Out[30]:
[[file:./obipy-resources/8573Fkw.png]]
:END:

As always, we instantiate our PCA model. By default all directions are kept.


#+BEGIN_SRC ipython :session :exports both :async t :results raw drawer
from sklearn.decomposition import PCA
pca = PCA()

#+END_SRC

#+RESULTS:
:RESULTS:
# Out[31]:
:END:

Then we fit the PCA model with our data. As PCA is an unsupervised algorithm,
there is no output y.


#+BEGIN_SRC ipython :session :exports both :async t :results raw drawer
pca.fit(X_blob)

#+END_SRC

#+RESULTS:
:RESULTS:
# Out[32]:
#+BEGIN_EXAMPLE
  PCA(copy=True, iterated_power='auto', n_components=None, random_state=None,
  svd_solver='auto', tol=0.0, whiten=False)
#+END_EXAMPLE
:END:

Then we can transform the data, projected on the principal components:


#+BEGIN_SRC ipython :session :exports both :async t :results raw drawer
X_pca = pca.transform(X_blob)
​
plt.scatter(X_pca[:, 0], X_pca[:, 1], c=y, linewidths=0, s=30)
plt.xlabel("first principal component")
plt.ylabel("second principal component");

pca = PCA(n_components=1).fit(X_blob)

X_blob.shape

pca.transform(X_blob).shape

#+END_SRC

#+RESULTS:
:RESULTS:
0 - cf46b9aa-7a78-4de6-af07-61156f6db4ae
:END:

On the left of the plot you can see the four points that were on the top right
before. PCA found fit first component to be along the diagonal, and the second
to be perpendicular to it. As PCA finds a rotation, the principal components are
always at right angles ("orthogonal") to each other.

** Dimensionality Reduction for Visualization with PCA
Consider the digits dataset. It cannot be visualized in a single 2D plot, as it
has 64 features. We are going to extract 2 dimensions to visualize it in, using
the example from the sklearn examples here


#+BEGIN_SRC ipython :session :exports both :async t :results raw drawer
from figures import digits_plot
digits_plot()

#+END_SRC

#+RESULTS:
:RESULTS:
# Out[34]:
[[file:./obipy-resources/8573Su2.png]]
:END:

​ Note that this projection was determined without any information about the
labels (represented by the colors): this is the sense in which the learning is
unsupervised. Nevertheless, we see that the projection gives us insight into the
distribution of the different digits in parameter space.

EXERCISE: Visualize the iris dataset using the first two principal components,
and compare this visualization to using two of the original features.

# %load solutions/07A_iris-pca.py
